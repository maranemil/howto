Hereâ€™s a complete example of a CRUD application using SvelteKit and SQLite. This example demonstrates how to manage a simple "Tasks" table with basic operations: Create, Read, Update, and Delete.

Prerequisites


Install SvelteKit:
Bashnpm create svelte@latest my-app
cd my-app
npm install



Install dependencies:
Bashnpm install better-sqlite3 drizzle-orm




1. Setup SQLite Database
Create a file database.js in the src/lib folder to manage the SQLite connection.
Javascript// src/lib/database.js
import Database from 'better-sqlite3';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';

// Initialize SQLite database
const sqlite = new Database('tasks.db');
export const db = drizzle(sqlite);

// Define the "tasks" table
export const tasksTable = sqliteTable('tasks', {
    id: integer('id').primaryKey().autoIncrement(),
    title: text('title').notNull(),
    description: text('description'),
});


2. Create the Database Table
Run the following script to create the tasks table:
Javascript// src/lib/setup.js
import { db, tasksTable } from './database.js';

db.run(`
    CREATE TABLE IF NOT EXISTS tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        description TEXT
    )
`);
console.log('Database initialized.');

Run this script once using Node.js:
Bashnode src/lib/setup.js


3. SvelteKit Endpoints for CRUD
Create API routes in the src/routes/api/tasks folder.
GET: Fetch All Tasks
Javascript// src/routes/api/tasks/+server.js
import { db, tasksTable } from '$lib/database';

export async function GET() {
    const tasks = db.select().from(tasksTable).all();
    return new Response(JSON.stringify(tasks), { status: 200 });
}

POST: Create a Task
Javascript// src/routes/api/tasks/+server.js
export async function POST({ request }) {
    const { title, description } = await request.json();
    db.insert(tasksTable).values({ title, description }).run();
    return new Response('Task created', { status: 201 });
}

PUT: Update a Task
Javascript// src/routes/api/tasks/[id]/+server.js
export async function PUT({ params, request }) {
    const { id } = params;
    const { title, description } = await request.json();
    db.update(tasksTable).set({ title, description }).where(tasksTable.id.eq(id)).run();
    return new Response('Task updated', { status: 200 });
}

DELETE: Delete a Task
Javascript// src/routes/api/tasks/[id]/+server.js
export async function DELETE({ params }) {
    const { id } = params;
    db.delete(tasksTable).where(tasksTable.id.eq(id)).run();
    return new Response('Task deleted', { status: 200 });
}


4. Frontend Example
Create a Svelte component to interact with the API.
Svelte<script>
    let tasks = [];
    let newTask = { title: '', description: '' };

    // Fetch tasks
    async function loadTasks() {
        const res = await fetch('/api/tasks');
        tasks = await res.json();
    }

    // Create a task
    async function createTask() {
        await fetch('/api/tasks', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newTask),
        });
        newTask = { title: '', description: '' };
        loadTasks();
    }

    // Delete a task
    async function deleteTask(id) {
        await fetch(`/api/tasks/${id}`, { method: 'DELETE' });
        loadTasks();
    }

    loadTasks();
</script>

<h1>Task Manager</h1>

<form on:submit|preventDefault={createTask}>
    <input bind:value={newTask.title} placeholder="Title" required />
    <input bind:value={newTask.description} placeholder="Description" />
    <button type="submit">Add Task</button>
</form>

<ul>
    {#each tasks as task}
        <li>
            <strong>{task.title}</strong>: {task.description}
            <button on:click={() => deleteTask(task.id)}>Delete</button>
        </li>
    {/each}
</ul>


Summary
This example demonstrates:

SQLite for database management.
Drizzle ORM for type-safe queries.
SvelteKit API routes for backend logic.
A simple Svelte frontend for user interaction.

You can expand this further by adding features like task editing, validation, or authentication.


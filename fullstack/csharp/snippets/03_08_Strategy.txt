The Strategy Pattern is a behavioral design pattern that allows you to define a family 
of algorithms, encapsulate each one, and make them interchangeable. 
Using generics in C# can make the implementation of the Strategy Pattern more 
flexible and type-safe. Here's an example of how to implement the Strategy 
Pattern using generics in C#:

Example: Strategy Pattern with Generics
Code kopieren



using System;

// Define the generic Strategy interface
public interface IStrategy<T>
{
    void Execute(T data);
}

// Implement specific strategies
public class PrintStrategy : IStrategy<string>
{
    public void Execute(string data)
    {
        Console.WriteLine($"Printing: {data}");
    }
}

public class MultiplyStrategy : IStrategy<int>
{
    public void Execute(int data)
    {
        Console.WriteLine($"Result: {data * 2}");
    }
}

// Context class that uses the strategy
public class Context<T>
{
    private IStrategy<T> _strategy;

    public Context(IStrategy<T> strategy)
    {
        _strategy = strategy;
    }

    public void SetStrategy(IStrategy<T> strategy)
    {
        _strategy = strategy;
    }

    public void ExecuteStrategy(T data)
    {
        _strategy.Execute(data);
    }
}

// Usage
class Program
{
    static void Main(string[] args)
    {
        // Using string strategy
        var stringContext = new Context<string>(new PrintStrategy());
        stringContext.ExecuteStrategy("Hello, Generics!");

        // Using integer strategy
        var intContext = new Context<int>(new MultiplyStrategy());
        intContext.ExecuteStrategy(5);
    }
}

Key Points:
Generic Interface: The IStrategy<T> interface defines a contract for strategies with a generic 
type parameter.
Flexible Context: The Context<T> class can work with any type of strategy, making it reusable
and type-safe.
Interchangeable Strategies: You can switch strategies at runtime using the SetStrategy method.

This approach ensures that your code is clean, extensible, and adheres to the Open/Closed Principle.


-----------------------------------------
https://learn.microsoft.com/de-de/dotnet/csharp/programming-guide/generics/generic-methods
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics
https://refactoring.guru/design-patterns/strategy/csharp/example
https://w3schools.tech/de/tutorial/csharp/csharp_generics
https://refactoring.guru/design-patterns/strategy/php/example#lang-features
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods


# https://learn.microsoft.com/de-de/dotnet/csharp/language-reference/builtin-types/built-in-types
# https://gehirnwindung.de/categories/csharp/datentypen

C#-Typ-Schl√ºsselwort	.NET-Typ
bool	System.Boolean
byte	System.Byte
sbyte	System.SByte
char	System.Char
decimal	System.Decimal
double	System.Double
float	System.Single
int	System.Int32
uint	System.UInt32
nint	System.IntPtr
nuint	System.UIntPtr
long	System.Int64
ulong	System.UInt64
short	System.Int16
ushort	System.UInt16

C#-Typschl√ºsselwort	.NET-Typ
object	System.Object
string	System.String
delegate	System.Delegate
dynamic	System.Object

-------------------------

// DEKLARATION / BEZEICHNER   10 variante  z 1 _
int _, _z, _1, _1z,  _z1,  z, z_, z1,  z_1,   z1_ ;   // no var can start with number !!!

// korrekte Variablenbezeichner
long value;
byte value_12;
int VaLuE;
// fehlerhafte Variablenbezeichner
int 34value;
string message Text;
long value%long;

-------------------------

// ELEMENTARE DATENTYPEN VON .NET  ??

byte by1 = 123; Byte by2 = 123; 
short sh1 = 12345; Int16 sh2 = 12345; 
int in1 = -123456; Int32 in2 = -123456; 
double do1 = 123.456; Double do2 = 123.456; 
char ch1 = 'A'; Char ch2 = 'A'; 
string st1 = "65"; String st2 = "65"; 
bool bo1 = true; Boolean bo2 = true;
 
object o1 = 123; 
object o2 = 12345; 
object o3 = 123456; 
object o4 = 123.456; 
object o5 = 'A'; 
object o6 = "65"; 
object o7 = true;

-------------------

// LITERALZEICHEN (TYP-SUFFIX) 

float fl = 1.234f;
 
Console.WriteLine(1 / 3); // 0
Console.WriteLine(1d / 3);
Console.WriteLine(1 / 3D); 
Console.WriteLine(1.0 / 3); 
Console.WriteLine(1 / 3.0); 
Console.WriteLine(1m / 3); 
Console.WriteLine(1 / 3M); 


// IMPLIZITE TYPKONVERTIERUNG

do1 = ch1; 


// EXPLIZITE TYPKONVERTIERUNG

byte by = (byte)do1; 
short sh = (short)do1; 
int i = (int)do1; 
char ch = (char)do1; 
string s = do1.ToString(); 
bool b = Convert.ToBoolean(do1); 

by = byte.Parse(s);

--------------------------------

// IMPLIZIT TYPISIERTE VARIABLEN 
double pi = 3.14; 
var v = 100; 
v = (int)pi;

var sh_ti = (short)100; 
var i_ti = 100; 
var lg_ti = 100L; 
var fl_ti = 100f; 
var db_ti = 100.0; 


double pi = 3.14;
int v_int = 100;
short v_short = 100;
long v_long = 100;
float v_float = 100.00F;
double v_double = 100.00;

Console.WriteLine(pi);
Console.WriteLine(v_int);
Console.WriteLine(v_short);
Console.WriteLine(v_long);
Console.WriteLine(v_float);
Console.WriteLine(v_double);

----------------------------------

static void Main(string[] args)
{
  long value = 4711;
  Console.WriteLine("value = {0}", value);
  Console.ReadLine();
}

// Scoping
{int abc = 5;}
{int abc = 3;}

//  Default var
z1 = default; 
z = 1; 
Console.WriteLine(z); 
// error CS1644: Feature `default literal' cannot be used because it is not part of the C# 7.0 language specification

---------------------------------------

https://openbook.rheinwerk-verlag.de/visual_csharp_2012/1997_02_003.html#dodtpa310dc3e-560e-481e-b4c8-ceef4a3e3185

// In C#, variable scope refers to the context within which a variable is accessible. 
It determines where a variable can be used // in your code. Here's a breakdown of the different types of variable scope in C#:

//  1. Local Scope
// Definition: Variables declared inside a method, constructor, or block ({}) are local to that block.
// Accessibility: Only accessible within the block where they are declared.
// Example:

void ExampleMethod()
{
    int localVariable = 10; // Local scope
    Console.WriteLine(localVariable); // Accessible here
}
// Console.WriteLine(localVariable); // Error: Not accessible here


// 2. Class/Field Scope
// Definition: Variables declared directly within a class but outside any method, constructor, or property.
// Accessibility: Accessible throughout the class, depending on their access modifier (private, public, protected, etc.).
// Example:

class ExampleClass
{
    private int fieldVariable = 20; // Class/Field scope

    void Display()
    {
        Console.WriteLine(fieldVariable); // Accessible here
    }
}

// 3. Static Scope
// Definition: Variables declared with the static keyword belong to the class rather than an instance of the class.
// Accessibility: Shared across all instances of the class and accessed using the class name.
// Example:
// Code kopieren

class ExampleClass
{
    public static int staticVariable = 30; // Static scope
}

// Accessing static variable
Console.WriteLine(ExampleClass.staticVariable);

// 4. Parameter Scope
// Definition: Variables declared as parameters in a method or constructor.
// Accessibility: Only accessible within the method or constructor where they are defined.
// Example:
// Code kopieren

void Greet(string name) // Parameter scope
{
    Console.WriteLine($"Hello, {name}!"); // Accessible here
}

// 5. Block Scope
// Definition: Variables declared inside a block (e.g., if, for, while) are only accessible within that block.
// Accessibility: Limited to the block where they are declared.
// Example:
// Code kopieren

void LoopExample()
{
    for (int i = 0; i < 5; i++) // Block scope
    {
        Console.WriteLine(i); // Accessible here
    }
    // Console.WriteLine(i); // Error: Not accessible here
}


// Understanding variable scope is crucial for writing clean, maintainable, and bug-free code. It helps avoid unintended side
// effects and ensures variables are used only where needed.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace HelloWorld
{
	public class Program
	{
		public static void Main(string[] args)
		{
			Console.WriteLine("Hello, World!");

		}
	}
}

###############################################

In C# gibt es bestimmte Regeln und Grenzen, die f√ºr Variablenbezeichner (Namen von Variablen) gelten. Hier sind die wichtigsten Punkte:

1. Erlaubte Zeichen
Ein Variablenname darf nur Buchstaben (A‚ÄìZ, a‚Äìz), Ziffern (0‚Äì9) und den Unterstrich _ enthalten.
Der Name darf nicht mit einer Ziffer beginnen.

Beispiel:

Code kopieren
int _variable; // g√ºltig
int variable123; // g√ºltig
int 123variable; // ung√ºltig

2. Schl√ºsselw√∂rter vermeiden
Variablennamen d√ºrfen keine reservierten Schl√ºsselw√∂rter (z. B. int, class, if) sein.
Falls ein Schl√ºsselwort dennoch verwendet werden muss, kann es mit einem @-Pr√§fix versehen werden.

Beispiel:

Code kopieren
int @class = 5; // g√ºltig, aber nicht empfohlen

3. Gro√ü- und Kleinschreibung
C# unterscheidet zwischen Gro√ü- und Kleinschreibung. Das bedeutet, variable und Variable sind zwei unterschiedliche Bezeichner.

Beispiel:

Code kopieren
int variable = 10;
int Variable = 20; // beide sind g√ºltig, aber unterschiedlich

4. Maximale L√§nge
Es gibt keine spezifische Begrenzung der L√§nge eines Variablennamens in C#. Praktisch sollte der Name jedoch sinnvoll und lesbar bleiben.
5. Unicode-Unterst√ºtzung
Variablennamen k√∂nnen Unicode-Zeichen enthalten, einschlie√ülich Buchstaben aus anderen 
Sprachen oder Sonderzeichen wie √§, √ü, etc. Allerdings sollten solche Namen aus Gr√ºnden der Lesbarkeit vermieden werden.

Beispiel:

Code kopieren
int m√ºlltonne = 5; // g√ºltig, aber nicht ideal

6. Keine Leerzeichen
Ein Variablenname darf keine Leerzeichen enthalten.

Beispiel:

Code kopieren
int myVariable; // g√ºltig
int my Variable; // ung√ºltig

7. Konventionen (Best Practices)
Obwohl es technisch erlaubt ist, beliebige g√ºltige Namen zu verwenden, gibt es Konventionen:
Variablennamen sollten beschreibend und aussagekr√§ftig sein.
CamelCase wird h√§ufig verwendet (z. B. myVariableName).
Private Felder beginnen oft mit einem Unterstrich (z. B. _myField).
Zusammenfassung

Solange die oben genannten Regeln eingehalten werden, kannst du Variablennamen flexibel gestalten. 
Es ist jedoch ratsam, sich an Konventionen zu halten, um den Code lesbar und wartbar zu machen.

##############################################################

In C# gibt es verschiedene M√∂glichkeiten, auf Variablen zuzugreifen, abh√§ngig von ihrem G√ºltigkeitsbereich, ihrer Sichtbarkeit und ihrem Kontext. Hier sind die g√§ngigsten Methoden:

1. Direkter Zugriff
Wenn die Variable im selben G√ºltigkeitsbereich (Scope) definiert ist, kann direkt darauf zugegriffen werden.
Code kopieren
int zahl = 42;
Console.WriteLine(zahl); // Direkter Zugriff

2. Zugriff √ºber Klassenfelder (Instanzvariablen)
Auf Instanzvariablen wird √ºber ein Objekt der Klasse zugegriffen.
Code kopieren
public class Beispiel
{
    public int Zahl = 10;
}

Beispiel obj = new Beispiel();
Console.WriteLine(obj.Zahl); // Zugriff √ºber das Objekt

3. Zugriff auf statische Variablen
Statische Variablen geh√∂ren zur Klasse und nicht zu einer Instanz. Sie werden √ºber den Klassennamen aufgerufen.
Code kopieren
public class Beispiel
{
    public static int Zahl = 20;
}

Console.WriteLine(Beispiel.Zahl); // Zugriff √ºber den Klassennamen

4. Zugriff √ºber Eigenschaften (Properties)
Eigenschaften bieten eine kontrollierte M√∂glichkeit, auf private Felder zuzugreifen.
Code kopieren
public class Beispiel
{
    private int _zahl;
    public int Zahl
    {
        get { return _zahl; }
        set { _zahl = value; }
    }
}

Beispiel obj = new Beispiel();
obj.Zahl = 30; // Setzen der Variable
Console.WriteLine(obj.Zahl); // Zugriff √ºber die Eigenschaft

5. Zugriff √ºber Methoden
Variablen k√∂nnen √ºber Getter- und Setter-Methoden gelesen oder ge√§ndert werden.
Code kopieren
public class Beispiel
{
    private int _zahl;

    public int GetZahl()
    {
        return _zahl;
    }

    public void SetZahl(int value)
    {
        _zahl = value;
    }
}

Beispiel obj = new Beispiel();
obj.SetZahl(40); // Setzen der Variable
Console.WriteLine(obj.GetZahl()); // Zugriff √ºber die Methode

6. Zugriff auf globale Variablen (innerhalb eines Namespaces)
In C# gibt es keine echten globalen Variablen, aber statische Felder in einer Klasse k√∂nnen √§hnlich verwendet werden.
Code kopieren
public static class Globals
{
    public static int Zahl = 50;
}

Console.WriteLine(Globals.Zahl); // Zugriff auf "globale" Variable

7. Zugriff √ºber ref und out
Variablen k√∂nnen als Referenz oder Ausgabeparameter an Methoden √ºbergeben werden.
Code kopieren
void BeispielMethode(ref int zahl)
{
    zahl += 10;
}

int meineZahl = 5;
BeispielMethode(ref meineZahl);
Console.WriteLine(meineZahl); // Ausgabe: 15

8. Zugriff auf lokale Variablen in Closures
Lokale Variablen k√∂nnen in anonymen Methoden oder Lambda-Ausdr√ºcken verwendet werden.
Code kopieren
int zahl = 100;
Func<int> closure = () => zahl + 1;
Console.WriteLine(closure()); // Zugriff auf lokale Variable


Diese Methoden bieten Flexibilit√§t und Kontrolle √ºber den Zugriff auf Variablen in C#. Die Wahl der Methode h√§ngt von der gew√ºnschten Kapselung, dem Kontext und den Anforderungen des Codes ab.

https://learn.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-console?view=vs-2022
https://openbook.rheinwerk-verlag.de/visual_csharp_2012/1997_02_003.html#dodtpa310dc3e-560e-481e-b4c8-ceef4a3e3185

Die Grunddatentypen in C# sind vordefinierte Datentypen, die zur Darstellung von einfachen Werten verwendet werden. Dazu geh√∂ren int, bool, char, float, double, decimal und string. Diese Grunddatentypen sind Teil des C#-Sprachsyntax und k√∂nnen f√ºr die Deklaration von Variablen verwendet werden.

#######################################################################

Die Unterscheidung zwischen .NET-Datentypen und C#-Datentypen liegt haupts√§chlich in der Art und Weise, wie sie dargestellt werden und wie sie miteinander verbunden sind. Hier ist eine klare √úbersicht:

1. C#-Datentypen (Alias-Typen):
C# bietet sogenannte Alias-Datentypen, die einfacher und benutzerfreundlicher sind.
Diese Typen sind sprachspezifisch und dienen als Kurzform f√ºr die entsprechenden .NET-Typen.
Beispiele:
int ‚Üí Alias f√ºr System.Int32
double ‚Üí Alias f√ºr System.Double
bool ‚Üí Alias f√ºr System.Boolean
2. .NET-Datentypen (CLR-Typen):
Diese Typen sind Teil des Common Language Runtime (CLR)-Systems von .NET.
Sie sind plattformunabh√§ngig und werden von allen .NET-Sprachen (z. B. C#, VB.NET, F#) verwendet.
Beispiele:
System.Int32 ‚Üí Entspricht int in C#
System.Double ‚Üí Entspricht double in C#
System.Boolean ‚Üí Entspricht bool in C#
3. Hauptunterschiede:
Lesbarkeit: C#-Alias-Typen sind k√ºrzer und leichter zu lesen, z. B. int statt System.Int32.
Interoperabilit√§t: .NET-Typen sind universell und werden von allen .NET-Sprachen erkannt, w√§hrend C#-Alias-Typen spezifisch f√ºr C# sind.
Verwendung: In der Regel werden C#-Alias-Typen in C#-Code bevorzugt, da sie kompakter sind. Die .NET-Typen werden oft in Frameworks, Bibliotheken oder bei Reflektionen verwendet.
Beispiel:
Code kopieren
// C#-Alias-Typen
int zahl = 42;
double pi = 3.14;
bool istWahr = true;

// .NET-Typen
System.Int32 zahlNet = 42;
System.Double piNet = 3.14;
System.Boolean istWahrNet = true;


Beide Varianten sind funktional identisch, aber die Alias-Typen sind f√ºr den Alltag in C#-Code √ºblicher.

#######################################################################

https://w3schools.tech/de/tutorial/csharp/csharp_type_conversion

int myNumber = 10;
double myDouble = myNumber; // Implizite Umwandlung von int zu double
Console.WriteLine(myDouble); // Ausgabe: 10

double myDouble = 9.8;
int myInt = (int)myDouble; // Explizite Umwandlung von double zu int
Console.WriteLine(myInt); // Ausgabe: 9

#####################

Was muss beim Typkonvertierungs-Operator beachtet werden c#

Beim Implementieren eines Typkonvertierungsoperators in C# gibt es einige wichtige Punkte, die beachtet werden sollten, um sicherzustellen, dass der Code korrekt, sicher und verst√§ndlich ist:

1. Explizite vs. Implizite Konvertierung
Explizit (explicit): Wird verwendet, wenn die Konvertierung potenziell Datenverlust oder eine Ausnahme verursachen k√∂nnte. Der Benutzer muss die Konvertierung mit einem Cast explizit anfordern.
Code kopieren
public static explicit operator ZielTyp(QuellTyp obj)
{
    // Konvertierungslogik
}

Implizit (implicit): Wird verwendet, wenn die Konvertierung sicher ist und keine Daten verloren gehen.
Code kopieren
public static implicit operator ZielTyp(QuellTyp obj)
{
    // Konvertierungslogik
}

2. Symmetrische Konvertierungen
Wenn Sie eine Konvertierung von Typ A nach Typ B definieren, sollten Sie auch die umgekehrte Konvertierung (von Typ B nach Typ A) implementieren, falls sinnvoll. Dies erh√∂ht die Konsistenz und Benutzerfreundlichkeit.
3. Null-√úberpr√ºfung
Stellen Sie sicher, dass Sie auf null pr√ºfen, um NullReferenceExceptions zu vermeiden:
Code kopieren
public static explicit operator ZielTyp(QuellTyp obj)
{
    if (obj == null)
        throw new ArgumentNullException(nameof(obj));
    // Konvertierungslogik
}

4. Eindeutigkeit und Lesbarkeit
Vermeiden Sie Mehrdeutigkeiten bei der Konvertierung. Wenn mehrere Konvertierungsoperatoren existieren, k√∂nnte dies zu Verwirrung f√ºhren. Dokumentieren Sie die Konvertierungslogik klar.
5. Performance
Achten Sie darauf, dass die Konvertierung effizient ist, insbesondere wenn sie h√§ufig verwendet wird.
6. Beispiel

Hier ein vollst√§ndiges Beispiel f√ºr einen Typkonvertierungsoperator:

Code kopieren
public class Celsius
{
    public double Temperature { get; }

    public Celsius(double temperature)
    {
        Temperature = temperature;
    }

    // Implizite Konvertierung von Celsius nach Fahrenheit
    public static implicit operator Fahrenheit(Celsius c)
    {
        return new Fahrenheit(c.Temperature * 9 / 5 + 32);
    }
}

public class Fahrenheit
{
    public double Temperature { get; }

    public Fahrenheit(double temperature)
    {
        Temperature = temperature;
    }

    // Explizite Konvertierung von Fahrenheit nach Celsius
    public static explicit operator Celsius(Fahrenheit f)
    {
        return new Celsius((f.Temperature - 32) * 5 / 9);
    }
}

7. Testen
Testen Sie die Konvertierungen gr√ºndlich, um sicherzustellen, dass sie in allen Szenarien korrekt funktionieren, insbesondere bei Grenzwerten oder ung√ºltigen Eingaben.

Durch die Beachtung dieser Punkte k√∂nnen Sie robuste und benutzerfreundliche Typkonvertierungsoperatoren in C# implementieren.

#################################################################################

Was muss bei der Parse-Methode beachtet werden c#


Die Parse-Methode in C# wird verwendet, um Zeichenfolgen (Strings) in bestimmte Datentypen wie int, double, DateTime usw. zu konvertieren. Dabei gibt es einige wichtige Punkte zu beachten, um Fehler zu vermeiden und die Methode korrekt zu verwenden:

1. Format der Eingabe
Die Eingabezeichenfolge muss exakt dem erwarteten Format des Zieltyps entsprechen. Andernfalls wird eine FormatException ausgel√∂st.
Beispiel: int.Parse("123") funktioniert, aber int.Parse("123.45") f√ºhrt zu einem Fehler, da der Punkt nicht in ein int konvertiert werden kann.
2. Kulturabh√§ngigkeit
Die Parse-Methode ber√ºcksichtigt die Kultur (z. B. Dezimaltrennzeichen oder Datumsformate). Standardm√§√üig wird die aktuelle Kultur des Systems verwendet.
Beispiel: double.Parse("3,14") funktioniert in Deutschland (Komma als Dezimaltrennzeichen), aber in den USA wird ein Punkt erwartet (3.14).
L√∂sung: Verwenden Sie CultureInfo, um die Kultur explizit anzugeben:
Code kopieren
double value = double.Parse("3.14", CultureInfo.InvariantCulture);

3. Fehlerbehandlung
Wenn die Eingabe ung√ºltig ist, wird eine Ausnahme ausgel√∂st:
FormatException: Wenn die Zeichenfolge nicht im richtigen Format ist.
ArgumentNullException: Wenn die Eingabe null ist.
OverflowException: Wenn der Wert au√üerhalb des Bereichs des Zieltyps liegt.

Verwenden Sie TryParse, um Fehler zu vermeiden:
Code kopieren
if (int.TryParse("123", out int result))
{
    Console.WriteLine($"Erfolgreich: {result}");
}
else
{
    Console.WriteLine("Ung√ºltige Eingabe.");
}

4. Null- oder Leerzeichen
Eine leere oder null-Zeichenfolge f√ºhrt zu einer Ausnahme. Pr√ºfen Sie daher vor der Verwendung:
Code kopieren
string input = null;
if (!string.IsNullOrEmpty(input))
{
    int number = int.Parse(input);
}

5. Datums- und Zeitformate
Beim Parsen von Datums- und Zeitwerten (DateTime.Parse) muss das Format der Eingabe mit dem erwarteten Format √ºbereinstimmen. Auch hier kann CultureInfo hilfreich sein:
Code kopieren
DateTime date = DateTime.Parse("01.07.2025", new CultureInfo("de-DE"));

Zusammenfassung
Verwenden Sie TryParse, um Fehler sicher zu behandeln.
Achten Sie auf das richtige Format und die Kulturabh√§ngigkeit.
Pr√ºfen Sie Eingaben auf null oder leere Zeichenfolgen.
Beachten Sie m√∂gliche Ausnahmen wie FormatException oder OverflowException.

Mit diesen Punkten k√∂nnen Sie die Parse-Methode sicher und effektiv einsetzen! üòä

#################################################################################

Welche Vor- und Nachteile bietet die Convert-Klasse c#

https://learn.microsoft.com/de-de/dotnet/standard/base-types/type-conversion
https://www.das-grosse-computer-abc.de/CSharp/Fortgeschrittene-Grundlagen
https://foxyform.de/c-string-to-int/
https://learn.microsoft.com/de-de/dotnet/api/system.convert?view=net-8.0
https://openbook.rheinwerk-verlag.de/c_von_a_bis_z/010_c_praeprozessor_002.htm

int iZahl1, iZahl2;
 
// falls bei den ersten zwei Eingaben, etwas ung√ºltiges eingegeben wird, wird eine Exception ausgel√∂st
Console.Write("Bitte geben Sie die erste Zahl ein: ");
iZahl1 = Convert.ToInt32(Console.ReadLine());
Console.Write("Bitte geben Sie die zweite Zahl ein: ");
iZahl2 = Convert.ToInt32(Console.ReadLine());
Console.WriteLine("Das Ergebnis von {0} + {1} ist {2}", iZahl1, iZahl2, iZahl1 + iZahl2);

Console.WriteLine();
 
// falls bei den n√§chsten zwei Eingaben, etwas ung√ºltiges eingegeben wird, wird eine Fehlermeldung ausgegeben
Console.Write("Bitte geben Sie die erste Zahl ein: ");
if (!int.TryParse(Console.ReadLine(), out iZahl1))
    Console.WriteLine("Die eingegebene Zahl war ung√ºltig. iZahl1 wurde automatisch auf 0 gesetzt!");
Console.Write("Bitte geben Sie die zweite Zahl ein: ");
if (!int.TryParse(Console.ReadLine(), out iZahl2))
    Console.WriteLine("Die eingegebene Zahl war ung√ºltig. iZahl2 wurde automatisch auf 0 gesetzt!");
Console.WriteLine("Das Ergebnis von {0} + {1} ist {2}", iZahl1, iZahl2, iZahl1 + iZahl2);
 
Console.ReadKey();

try
{
    string str = "123";
    int num = int.Parse(str);
    Console.WriteLine("Der konvertierte Integer-Wert ist: " + num);
}
catch (FormatException)
{
    Console.WriteLine("Der √ºbergebene String konnte nicht in einen Integer konvertiert werden.");
}

----

// Eingabe-String
string input = "123";
int result;

// Konvertierung mit TryParse
bool success = int.TryParse(input, out result);

if (success)
{
    Console.WriteLine("Die Konvertierung war erfolgreich. Der Wert ist: " + result);
}
else
{
    Console.WriteLine("Die Konvertierung ist fehlgeschlagen.");
}

-----------------

string numString = "12345";
int num = Convert.ToInt32(numString);

-----------------

string input = "123";
int result;

if (int.TryParse(input, out result))
{
    Console.WriteLine("Die Konvertierung war erfolgreich. Der Integer-Wert ist: " + result);
}
else
{
    Console.WriteLine("Die Konvertierung ist fehlgeschlagen.");
}

-----------------

string input = "abc";
int result;

try
{
    result = int.Parse(input);
    Console.WriteLine("Die Konvertierung war erfolgreich. Der Integer-Wert ist: " + result);
}
catch (FormatException)
{
    Console.WriteLine("Ung√ºltiges Format. Bitte geben Sie eine g√ºltige Zahl ein.");
}

----------------------------

https://openbook.rheinwerk-verlag.de/visual_csharp_2012/1997_02_003.html#dodtpa310dc3e-560e-481e-b4c8-ceef4a3e3185


long value1 = 4711;
int value2 = Convert.ToInt32(value1);

int value = Convert.ToInt32(Console.ReadLine());

// Konvertierung des Typs 'string' zu 'int' nicht m√∂glich


short value1 = 436;
byte value2 = (byte)value1;
Console.WriteLine(value2);


// Beispiel: ..\Kapitel 2\CheckedSample
static void Main(string[] args) {
  // Zahleneingabe anfordern
  Console.Write("Geben Sie eine Zahl im Bereich von ");
  Console.Write("0...{0} ein: ", Int16.MaxValue);
  // Eingabe einem short-Typ zuweisen
  short value1 = Convert.ToInt16(Console.ReadLine());
  // √úberlaufpr√ºfung einschalten
  byte value2 = checked((byte)value1);
  Console.WriteLine(value2);
  Console.ReadLine();
}

#########################################

Die Convert-Klasse in C# ist eine n√ºtzliche Klasse, die h√§ufig verwendet wird, um Datentypen zu konvertieren. Hier sind die Vor- und Nachteile der Convert-Klasse:

Vorteile der Convert-Klasse:

Einfachheit und Benutzerfreundlichkeit
Die Convert-Klasse bietet eine einfache M√∂glichkeit, zwischen verschiedenen Datentypen zu konvertieren, ohne dass komplexer Code erforderlich ist. Beispiele sind Convert.ToInt32(), Convert.ToString(), etc.

Unterst√ºtzung f√ºr viele Typen
Sie unterst√ºtzt eine Vielzahl von Datentypen, einschlie√ülich numerischer Typen, Zeichenketten, Boolescher Werte und mehr.

Automatische Behandlung von null
Wenn ein null-Wert √ºbergeben wird, gibt die Convert-Klasse standardm√§√üig den Standardwert des Zieltyps zur√ºck (z. B. 0 f√ºr Zahlen oder false f√ºr Boolesche Werte), anstatt eine Ausnahme auszul√∂sen.

Konsistenz
Die Convert-Methoden sind konsistent benannt und leicht verst√§ndlich, was die Lesbarkeit und Wartbarkeit des Codes verbessert.

Flexibilit√§t bei der Konvertierung
Sie kann auch komplexere Konvertierungen durchf√ºhren, wie z. B. von einem DateTime-Objekt in eine Zeichenkette oder umgekehrt.

Nachteile der Convert-Klasse:

Fehleranf√§lligkeit bei ung√ºltigen Eingaben
Wenn die Eingabe nicht in den Zieltyp konvertiert werden kann (z. B. eine nicht numerische Zeichenkette in eine Zahl), wird eine Ausnahme ausgel√∂st (FormatException oder InvalidCastException).

Performance
Die Convert-Klasse kann in bestimmten Szenarien langsamer sein als direkte Typkonvertierungen oder das Verwenden von TryParse, insbesondere wenn viele Konvertierungen durchgef√ºhrt werden.

Keine Fehlerbehandlung bei ung√ºltigen Werten
Im Gegensatz zu Methoden wie int.TryParse() bietet die Convert-Klasse keine M√∂glichkeit, ung√ºltige Eingaben sicher zu behandeln, ohne eine Ausnahme auszul√∂sen.

Standardwerte k√∂nnen unerwartet sein
Die automatische R√ºckgabe von Standardwerten bei null-Eingaben kann zu unerwartetem Verhalten f√ºhren, wenn dies nicht ber√ºcksichtigt wird.

Fazit:

Die Convert-Klasse ist ideal f√ºr einfache und schnelle Konvertierungen, bei denen die Eingabewerte zuverl√§ssig sind. F√ºr Szenarien, in denen ung√ºltige Eingaben erwartet werden, ist es jedoch oft besser, Methoden wie TryParse zu verwenden, um Fehler sicher zu behandeln.

##############

Was bedeutet Typinferenz csharp

Typinferenz in C# (Type Inference) bedeutet, dass der Compiler den Datentyp einer Variablen automatisch ableitet, anstatt dass der Entwickler ihn explizit angeben muss. Dies wird durch das Schl√ºsselwort var erm√∂glicht. Der Compiler analysiert den zugewiesenen Wert und bestimmt daraus den Typ der Variablen.

Beispiel:
Code kopieren
var zahl = 42; // Der Compiler erkennt, dass "zahl" vom Typ int ist.
var text = "Hallo Welt"; // Der Compiler erkennt, dass "text" vom Typ string ist.

Vorteile:
K√ºrzerer Code: Der Code wird lesbarer und weniger redundant.
Flexibilit√§t: Besonders n√ºtzlich bei komplexen Typen wie anonymen Typen oder generischen Typen.

Einschr√§nkungen:
Der Typ muss zur Kompilierzeit eindeutig bestimmbar sein. Zum Beispiel:
Code kopieren
var x; // Funktioniert nicht, da kein Wert zugewiesen wurde.


Typinferenz macht den Code eleganter, ohne die Typsicherheit von C# zu beeintr√§chtigen.


##########

Wann sollte die Typinferenz benutzt werden und wann nicht in csharp


Typinferenz in C# verwenden

Die Typinferenz in C# sollte in bestimmten Situationen verwendet werden, um den Code lesbarer und √ºbersichtlicher zu gestalten. Sie ist besonders n√ºtzlich, wenn der Typ des Wertes klar und eindeutig ist, sodass die Verwendung von `var` die Notwendigkeit, den Typ explizit zu schreiben, erspart  Beispielsweise kann `var` in lokalen Variablen, in Schleifen und in Lambda-Ausdr√ºcken verwendet werden, um den Code k√ºrzer und einfacher zu gestalten  

Allerdings sollte die Typinferenz nicht in allen Situationen verwendet werden. Sie ist nicht geeignet, wenn der Typ des Wertes nicht eindeutig oder offensichtlich ist, da dies die Lesbarkeit des Codes beeintr√§chtigen kann  Auch bei Feldern, Methodenparametern oder R√ºckgabetypen sollte `var` nicht verwendet werden, da dies zu schwer zu findenden Fehlern f√ºhren kann, wenn sich der Typ in Zukunft √§ndert  

Zusammenfassend sollte die Typinferenz in C# in Situationen verwendet werden, in denen der Typ des Wertes eindeutig und offensichtlich ist, und nicht in Situationen, in denen der Typ nicht klar ist oder wenn √Ñnderungen des Typs zu Problemen f√ºhren k√∂nnten.

#####################################

Tabelle 2.3 Die elementaren Datentypen

.NET-Laufzeittyp	C# -Alias	CLS-konform	Wertebereich
Byte    byte  ja  0 ... 255
SByte  sbyte nein  ‚Äì128 ... 127
Int16  short  ja  ‚Äì215 ... 215 ‚Äì1
UInt16  ushort  nein  0 ... 65535
Int32t  int  ja  ‚Äì231 ... 231 ‚Äì1
UInt32  uint  nein  0 ... 232 ‚Äì1
Int64  long  ja  ‚Äì263 ... 263 ‚Äì1
UInt64  ulong  nein  0 ... 264 ‚Äì1
Single  float  ja  1,4 * 10‚Äì45 bis 3,4 * 1038
Double  double  ja  5,0 * 10‚Äì324 bis 1,7 * 10308
Decimal  decimal  ja  +/‚Äì79E27 ohne Dezimalpunktangabe; +/‚Äì7.9E-29, falls 28 Stellen hinter dem Dezimalpunkt angegeben werden. Die kleinste darstellbare Zahl betr√§gt +/‚Äì1.0E-29.
Char  char  ja  Unicode-Zeichen zwischen 0 und 65535
String  string  ja  ca. 231 Unicode-Zeichen
Boolean  bool  ja  true oder false
Object  object  ja  Eine Variable vom Typ Object kann jeden anderen Datentyp enthalten, ist also universell.



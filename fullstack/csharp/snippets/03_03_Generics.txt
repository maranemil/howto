###########################
Generics 
###########################

https://openbook.rheinwerk-verlag.de/visual_csharp_2012/1997_09_001.html#dodtp066354eb-ea00-4a8d-aa5a-fa7bd96e026d
https://learn.microsoft.com/de-de/dotnet/csharp/language-reference/language-specification/readme
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/readme
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables
https://openbook.rheinwerk-verlag.de/visual_csharp_2012/



-------------------------------------------------------------

Generics in C# are a powerful feature that allows developers to create classes, methods, 
delegates, and interfaces that can work with different data types while maintaining type safety
 and reusability.

 This concept enables the creation of general-purpose classes and methods, where the actual 
 data type is determined at compile time.

One of the primary benefits of using generics is that they enhance code reusability, type safety, 
and performance. By using generics, you can avoid the costs and risks associated with runtime 
type conversions or boxing operations.

 For example, a generic class like GenericList<T> can be used to create lists of different types, 
 such as integers, strings, or custom objects, without the need to write separate classes for each type.

Generics are widely used in C# for implementing various collection classes and data structures 
such as lists, dictionaries, and queues. These data structures can store and manipulate elements 
of any data type efficiently.
 For instance, the List<T> class in C# is a generic collection that can store a list of items
  of any type, as shown in the following code:


List<int> integerList = new List<int>();
integerList.Add(1);
integerList.Add(2);

List<string> stringList = new List<string>();
stringList.Add("Apple");
stringList.Add("Banana");   


In addition to collections, generics can also be applied to methods, delegates, and events. 
For example, a generic method can be defined to work with different data types, allowing for
more flexible and reusable code.

Furthermore, generics can be constrained to ensure that the type parameters meet specific criteria. 
Constraints allow you to define requirements for the generic type parameter, ensuring that 
it supports certain operations or has specific properties.
Common constraints include specifying that a type must be a reference type, a value type, 
or must implement a particular interface.

Overall, generics in C# provide a flexible and efficient way to write code that can handle 
different data types while maintaining type safety and reusability.



https://learn.microsoft.com/de-de/dotnet/csharp/fundamentals/types/generics
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics


-------------------------------------------------------------


https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics
https://www.geeksforgeeks.org/c-sharp/c-sharp-generics-introduction/
https://w3schools.tech/de/tutorial/csharp/csharp_generics
https://www.tutorialspoint.com/csharp/csharp_generics.htm


Generics in C# are a powerful feature that allows you to define classes, methods, interfaces, 
or delegates with a placeholder for the type of data they operate on. 
This makes your code more reusable, type-safe, and efficient by enabling it to work with any 
data type without sacrificing performance or type checking.

Key Features of Generics:
Type Safety: Generics ensure that type mismatches are caught at compile time, reducing runtime errors.
Reusability: You can write a single generic class or method that works with different data types.
Performance: Generics avoid boxing and unboxing (for value types), improving performance.
Example of Generics in C#:

Generic Class:
Code kopieren
public class GenericClass<T>
{
    private T data;

    public void SetData(T value)
    {
        data = value;
    }

    public T GetData()
    {
        return data;
    }
}

// Usage
var intInstance = new GenericClass<int>();
intInstance.SetData(42);
Console.WriteLine(intInstance.GetData()); // Output: 42

var stringInstance = new GenericClass<string>();
stringInstance.SetData("Hello");
Console.WriteLine(stringInstance.GetData()); // Output: Hello

Generic Method:
Code kopieren
public class GenericMethodExample
{
    public void Display<T>(T value)
    {
        Console.WriteLine($"Value: {value}");
    }
}

// Usage
var example = new GenericMethodExample();
example.Display(100); // Output: Value: 100
example.Display("Generics"); // Output: Value: Generics

Generic Interface:
Code kopieren
public interface IGenericInterface<T>
{
    T Process(T input);
}

public class GenericImplementation : IGenericInterface<int>
{
    public int Process(int input)
    {
        return input * 2;
    }
}

// Usage
var implementation = new GenericImplementation();
Console.WriteLine(implementation.Process(5)); // Output: 10


Generics are widely used in C# frameworks, such as in collections (List<T>, Dictionary<TKey, TValue>)
 and LINQ methods, making them an essential tool for modern C# development.


--------------
###########################
###########################

In C#, generics are declared when you want to create reusable and type-safe code that can work 
with any data type. They allow you to define classes, methods, interfaces, or delegates with
 a placeholder for the type, which is specified when the generic is used. Here's a breakdown 
 of when and how generics are declared:

1. Generic Classes

Declared when you need a class to operate on different data types without duplicating code.

Code kopieren
public class GenericClass<T>
{
    private T data;

    public void SetData(T value)
    {
        data = value;
    }

    public T GetData()
    {
        return data;
    }
}

2. Generic Methods

Declared when a method needs to perform the same operation on different types.

Code kopieren
public class Example
{
    public void Print<T>(T value)
    {
        Console.WriteLine(value);
    }
}

3. Generic Interfaces

Declared when you want to define a contract that works with multiple types.

Code kopieren
public interface IGenericInterface<T>
{
    T Process(T input);
}

4. Generic Delegates

Declared when you need a delegate that can handle different types.

Code kopieren
public delegate T GenericDelegate<T>(T input);

When to Use Generics:
When you need type safety without boxing/unboxing.
When you want to reuse code for multiple types.
When you want to improve performance by avoiding runtime type checks.

Generics are particularly useful for collections (e.g., List<T>, Dictionary<TKey, TValue>) 
and algorithms that need to work with various data types.


-----------------------------------------------------------------
###########################
###########################
In C#, elements are declared using data types, which define the kind of data a variable can hold.
 These types are broadly categorized into the following:

1. Value Types
Store data directly in memory.
Examples:
Numeric Types:
int (e.g., whole numbers: -2147483648 to 2147483647)
double (e.g., floating-point numbers: 1.5, 3.14)
decimal (e.g., high-precision numbers: 19.99m)
float, byte, short, long, etc.
Boolean:
bool (e.g., true or false)
Character:
char (e.g., single character: 'A', '1')
Structs and Enums (custom value types).
2. Reference Types
Store references to memory locations.
Examples:
Strings:
string (e.g., "Hello, World!")
Objects:
object (base type for all data types)
Arrays:
int[], string[], etc.
Classes, Interfaces, Delegates, etc.
3. Nullable Types
Allow value types to hold null.
Example: int?, double?.
4. Dynamic Types
Type is resolved at runtime.
Example: dynamic.
5. Pointer Types (unsafe context)
Used for low-level memory manipulation.
Example: int*.

C# is strongly typed, meaning every variable must have a defined type, ensuring type safety and
 reducing runtime errors.


-----------------------------------------------------------------
###########################
###########################

In C#, generics allow you to define type-safe and reusable code by deferring the specification of
 one or more types until the class, method, or interface is instantiated or called. 
 Here are the types of elements that can be declared using generics:

1. Generic Classes
Classes that can work with any data type.
Example:
Code kopieren
public class GenericClass<T>
{
    public T Data { get; set; }
}

2. Generic Methods
Methods that can operate on different data types without duplication.
Example:
Code kopieren
public void Display<T>(T value)
{
    Console.WriteLine(value);
}

3. Generic Interfaces
Interfaces that define methods or properties with type parameters.
Example:
Code kopieren
public interface IGenericInterface<T>
{
    T GetData();
}

4. Generic Delegates
Delegates that can encapsulate methods with type parameters.
Example:
Code kopieren
public delegate T GenericDelegate<T>(T value);

5. Generic Constraints
You can apply constraints to restrict the types that can be used with generics.
Example:
Code kopieren
public class GenericClass<T> where T : class
{
    public T Data { get; set; }
}

6. Built-in Generic Types
C# provides several built-in generic types, such as:
List<T>
Dictionary<TKey, TValue>
Queue<T>
Stack<T>
Nullable<T>

Generics are a powerful feature in C# that enhance type safety, reduce code duplication, 
and improve performance by avoiding boxing/unboxing operations.


-------------------------------------------------
###########################
###########################
In C#, constants are immutable values that are defined at compile time and cannot be changed 
during the execution of the program. They are declared using the const keyword and are typically
 used for values that are known and fixed throughout the program's lifecycle, such as
  mathematical constants or configuration values.

Key Features of Constants in C#:
Immutable: Once assigned, their value cannot be modified.
Compile-Time Values: The value of a constant must be known at compile time.
Limited to Built-In Types: Constants can only be of built-in types like int, double, string, etc. 
Custom objects cannot be constants.

Syntax:
Code kopieren
const <data_type> <constant_name> = <value>;

Example:
Code kopieren
using System;

class Program
{
    const double Pi = 3.14159; // A constant for Pi
    const int MaxUsers = 100; // A constant for maximum users

    static void Main()
    {
        Console.WriteLine($"Value of Pi: {Pi}");
        Console.WriteLine($"Maximum Users Allowed: {MaxUsers}");
    }
}

Notes:
Constants are implicitly static, so they can be accessed without creating an instance of the class.
If you need a value that is immutable but determined at runtime, consider using the readonly 
keyword instead of const.

-------------------------------------------------
###########################
Generics and inheritance
###########################

https://openbook.rheinwerk-verlag.de/visual_csharp_2012/1997_09_004.html#dodtp83eebf09-cfc6-40cc-a43e-4d7d1431b36b
https://openbook.rheinwerk-verlag.de/visual_csharp_2012/1997_09_005.html#dodtpf720e7cf-50ca-4037-9288-96609f8ecc28

Generics und Vererbung

In C#, generics and inheritance can be combined to create flexible and reusable code. 
Here's an overview with examples:

1. Generic Classes with Inheritance

A generic class can inherit from another class, which may or may not be generic.

Code kopieren
// Base class
public class Animal
{
    public string Name { get; set; }
}

// Generic derived class
public class Cage<T> where T : Animal
{
    public T Occupant { get; set; }

    public void DisplayOccupant()
    {
        Console.WriteLine($"This cage contains: {Occupant.Name}");
    }
}


Here, Cage<T> is a generic class that restricts T to types derived from Animal 
using the where T : Animal constraint.

2. Generic Constraints with Interfaces

You can also constrain a generic type to implement specific interfaces.

Code kopieren
// Interface
public interface ICanFly
{
    void Fly();
}

// Base class
public class Bird : Animal, ICanFly
{
    public void Fly()
    {
        Console.WriteLine($"{Name} is flying!");
    }
}

// Generic class with interface constraint
public class Aviary<T> where T : Animal, ICanFly
{
    public T Bird { get; set; }

    public void LetBirdFly()
    {
        Bird.Fly();
    }
}


In this example, Aviary<T> ensures that T is both an Animal and implements the ICanFly interface.

3. Combining Generics and Abstract Classes

You can use generics with abstract classes to enforce specific behaviors in derived classes.

Code kopieren
// Abstract base class
public abstract class Repository<T>
{
    public abstract void Add(T item);
    public abstract T Get(int id);
}

// Concrete implementation
public class ProductRepository : Repository<Product>
{
    private List<Product> _products = new List<Product>();

    public override void Add(Product item)
    {
        _products.Add(item);
    }

    public override Product Get(int id)
    {
        return _products.FirstOrDefault(p => p.Id == id);
    }
}

// Product class
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
}


Here, Repository<T> is a generic abstract class, and ProductRepository provides a concrete 
implementation for Product.

Key Points:
Use where constraints to enforce type rules for generics.
Combine inheritance and interfaces to create robust, reusable designs.
Abstract classes with generics allow for flexible and extensible architectures.

This approach ensures type safety while maintaining flexibility in your code.


---------------------------------------------------------
###########################
Type conversion of generics
###########################



In C#, type conversion with generics can be a bit tricky due to type safety and runtime constraints. 
Here are three approaches to handle type conversion with generics:

1. Using Convert.ChangeType

You can use Convert.ChangeType to convert a generic type to another type at runtime. However, 
this works only for types that implement IConvertible.

Code kopieren
public T ConvertTo<T>(object input)
{
    return (T)Convert.ChangeType(input, typeof(T));
}


Usage:

Code kopieren
int result = ConvertTo<int>("123"); // Converts string to int

2. Using as Keyword

If you're working with reference types or nullable types, you can use the as keyword for safe casting.

Code kopieren
public T SafeCast<T>(object input) where T : class
{
    return input as T;
}


Usage:

Code kopieren
string result = SafeCast<string>(123); // Returns null since 123 is not a string

3. Using Reflection

For more complex scenarios, reflection can be used to dynamically cast types. This is less 
performant and should be used sparingly.

Code kopieren
public T CastWithReflection<T>(object input)
{
    return (T)Convert.ChangeType(input, typeof(T));
}


Usage:

Code kopieren
double result = CastWithReflection<double>("123.45"); // Converts string to double

Notes:
Always ensure type compatibility to avoid runtime exceptions.
Use constraints (where T : ...) to limit the types that can be passed to your generic methods or 
classes.
Reflection should be avoided in performance-critical applications.

Let me know if you'd like further clarification! üòä


--------------
###########################
csharp Nullable generics
###########################

In C#, nullable generics allow you to work with value types that can also represent null. 
This is achieved using the Nullable<T> structure or the shorthand T?. Here's an overview and examples:

Key Points:

Nullable Value Types:

Nullable<T> or T? allows value types (e.g., int, double) to hold null.
Example: int? is shorthand for Nullable<int>.

Generic Constraints:

When working with generics, you can use nullable types without constraints.
Use default(T) to handle cases where T might be a nullable type.

Nullable Reference Types:

Introduced in C# 8.0, nullable reference types (string?, etc.) help manage nullability 
in reference types.

Example 1: Nullable Value Type in Generics
Code kopieren
public T? GetNullableValue<T>() where T : struct
{
    return default(T?); // Returns null for nullable value types
}

Example 2: Handling Nullable Types in Generics
Code kopieren
public T GetDefaultValue<T>()
{
    return default(T); // Works for both nullable and non-nullable types
}

Example 3: Nullable Reference Types
Code kopieren
public T? GetNullableReference<T>() where T : class
{
    return null; // Returns null for reference types
}


These examples demonstrate how nullable generics can be used flexibly in C#. Let me know 
if you'd like further clarification!

------------------------------------------------------

####################
Indexes
#####################


https://openbook.rheinwerk-verlag.de/visual_csharp_2012/1997_10_007.html#dodtp64981a13-8ca2-4f1e-9bbd-7570fae18cc6


In C#, indexers allow objects to be indexed like arrays. However, generic indexers are not 
directly supported because properties (and indexers are essentially specialized properties)
 cannot be generic. That said, you can work around this limitation by using generic types in 
 the class or method containing the indexer.

Here are three approaches to using generics with indexers:

1. Generic Class with Indexer

You can define a generic class and use the generic type in the indexer.

Code kopieren
public class GenericCollection<T>
{
    private Dictionary<int, T> _items = new Dictionary<int, T>();

    public T this[int index]
    {
        get => _items.ContainsKey(index) ? _items[index] : default;
        set => _items[index] = value;
    }
}


Usage:

Code kopieren
var collection = new GenericCollection<string>();
collection[0] = "Hello";
Console.WriteLine(collection[0]); // Output: Hello

2. Generic Method with Indexer Logic

If you need a generic-like behavior for indexers, you can use a method instead of an indexer.

Code kopieren
public class GenericIndexer
{
    private Dictionary<int, object> _items = new Dictionary<int, object>();

    public T GetItem<T>(int index)
    {
        return _items.ContainsKey(index) ? (T)_items[index] : default;
    }

    public void SetItem<T>(int index, T value)
    {
        _items[index] = value;
    }
}


Usage:

Code kopieren
var genericIndexer = new GenericIndexer();
genericIndexer.SetItem(0, "Hello");
Console.WriteLine(genericIndexer.GetItem<string>(0)); // Output: Hello

3. Using Overloaded Indexers

You can overload indexers to simulate generic behavior for specific types.

Code kopieren
public class OverloadedIndexer
{
    private Dictionary<int, string> _stringItems = new Dictionary<int, string>();
    private Dictionary<int, int> _intItems = new Dictionary<int, int>();

    public string this[int index, string type]
    {
        get => _stringItems.ContainsKey(index) ? _stringItems[index] : null;
        set => _stringItems[index] = value;
    }

    public int this[int index, int type]
    {
        get => _intItems.ContainsKey(index) ? _intItems[index] : 0;
        set => _intItems[index] = value;
    }
}


Usage:

Code kopieren
var overloaded = new OverloadedIndexer();
overloaded[0, "string"] = "Hello";
overloaded[1, 0] = 42;

Console.WriteLine(overloaded[0, "string"]); // Output: Hello
Console.WriteLine(overloaded[1, 0]);       // Output: 42


While C# doesn't support generic indexers directly, these approaches provide flexibility to 
achieve similar functionality.


----------------------------------------

Overloading indexers


https://openbook.rheinwerk-verlag.de/visual_csharp_2012/1997_10_007.html#dodtp64981a13-8ca2-4f1e-9bbd-7570fae18cc6



In C#, indexers allow objects to be indexed like arrays. You can overload indexers by defining 
multiple indexers with different parameter types or numbers of parameters. Here's how you can do it:

Example 1: Overloading with Different Parameter Types
Code kopieren
public class Sample
{
    private Dictionary<int, string> intDictionary = new Dictionary<int, string>();
    private Dictionary<string, string> stringDictionary = new Dictionary<string, string>();

    // Indexer with integer parameter
    public string this[int index]
    {
        get => intDictionary.ContainsKey(index) ? intDictionary[index] : null;
        set => intDictionary[index] = value;
    }

    // Indexer with string parameter
    public string this[string key]
    {
        get => stringDictionary.ContainsKey(key) ? stringDictionary[key] : null;
        set => stringDictionary[key] = value;
    }
}

Example 2: Overloading with Multiple Parameters
Code kopieren
public class Matrix
{
    private int[,] data = new int[10, 10];

    // Indexer with two parameters
    public int this[int row, int column]
    {
        get => data[row, column];
        set => data[row, column] = value;
    }
}

Example 3: Overloading with Custom Types
Code kopieren
public class CustomIndexer
{
    private Dictionary<(int, string), string> customDictionary = new Dictionary<(int, string), string>();

    // Indexer with a tuple as a parameter
    public string this[int id, string name]
    {
        get => customDictionary.ContainsKey((id, name)) ? customDictionary[(id, name)] : null;
        set => customDictionary[(id, name)] = value;
    }
}

Key Points:
Indexers can have different parameter types or numbers of parameters to overload them.
They follow the same syntax as properties, with get and set accessors.
Overloading indexers is useful for creating flexible and intuitive APIs for your classes.



------------------------------------------------

Lambda

https://openbook.rheinwerk-verlag.de/visual_csharp_2012/1997_10_003.html#dodtp46efe5c6-5001-428b-b4f9-95b9b613bc34



In C#, lambda expressions are a concise way to represent anonymous functions. 
They are often used with LINQ queries, delegates, or functional programming constructs. 
The syntax uses the => operator, known as the lambda operator, to separate the input parameters
 from the expression or statement block.

Syntax
Code kopieren
(parameters) => expression


or

Code kopieren
(parameters) => { statements }

Examples

Simple Lambda Expression:

Code kopieren
Func<int, int> square = x => x * x;
Console.WriteLine(square(5)); // Output: 25


Lambda with Multiple Parameters:

Code kopieren
Func<int, int, int> add = (x, y) => x + y;
Console.WriteLine(add(3, 7)); // Output: 10


Lambda with Statement Block:

Code kopieren
Action<string> greet = name => 
{
    Console.WriteLine($"Hello, {name}!");
};
greet("Alice"); // Output: Hello, Alice!


Using Lambda in LINQ:

Code kopieren
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var evenNumbers = numbers.Where(n => n % 2 == 0).ToList();
Console.WriteLine(string.Join(", ", evenNumbers)); // Output: 2, 4

Key Points
Type Inference: The compiler infers the types of parameters, so you don't need to specify 
them explicitly.
Flexibility: Lambdas can be used wherever a delegate type is expected.
Readability: They make code more concise and readable, especially in LINQ queries.

Let me know if you'd like further clarification or examples! üòä

---------------------------------------------
##################################
Erweiterungsmethoden
##################################


https://openbook.rheinwerk-verlag.de/visual_csharp_2012/1997_10_004.html#dodtp8cb905ec-01d5-4365-bbe2-e8e5057383db



In C#, extension methods allow you to add new methods to existing types without modifying their 
source code or creating a derived type. They are static methods defined in a static class but are
 called as if they were instance methods on the extended type.

Key Points:
Static Class: Extension methods must be defined in a static class.
Static Method: The method itself must be static.
this Keyword: The first parameter of the method specifies the type it extends, prefixed with the 
this keyword.

Example:
Code kopieren
using System;

namespace ExtensionMethodDemo
{
    public static class StringExtensions
    {
        // Extension method for the string type
        public static string ToTitleCase(this string str)
        {
            if (string.IsNullOrWhiteSpace(str))
                return str;

            var words = str.Split(' ');
            for (int i = 0; i < words.Length; i++)
            {
                if (words[i].Length > 0)
                {
                    words[i] = char.ToUpper(words[i][0]) + words[i].Substring(1).ToLower();
                }
            }
            return string.Join(" ", words);
        }
    }

    class Program
    {
        static void Main()
        {
            string sentence = "hello world from c#";
            Console.WriteLine(sentence.ToTitleCase()); // Output: "Hello World From C#"
        }
    }
}

How It Works:
The ToTitleCase method is defined in a static class StringExtensions.
The this string str parameter indicates that this method extends the string type.
You can call ToTitleCase directly on any string instance as if it were a built-in method.
Benefits:
Non-Intrusive: No need to modify the original type.
Reusability: Easily reuse the method across your project.
Readability: Makes code more intuitive and cleaner.
Limitations:
Extension methods cannot access private or protected members of the type they extend.
They are less discoverable compared to instance methods.

This feature is particularly useful for adding utility methods to existing types like string, int, 
or even custom classes.

--------------------


Operator√ºberladung


https://openbook.rheinwerk-verlag.de/visual_csharp_2012/1997_10_006.html#dodtpe76ab009-5081-4073-9857-037d41e5385a


In C# k√∂nnen Operatoren √ºberladen werden, um benutzerdefinierte Implementierungen f√ºr bestimmte 
Operationen bereitzustellen. Dies ist besonders n√ºtzlich, wenn Sie mit benutzerdefinierten Typen 
arbeiten und m√∂chten, dass diese sich wie eingebaute Typen verhalten.

Grundlagen der Operator√ºberladung
Syntax: Ein Operator wird √ºber die Methode operator definiert.
Einschr√§nkungen: Nicht alle Operatoren k√∂nnen √ºberladen werden (z. B. = kann nicht √ºberladen werden).
Paarweise √úberladung: Einige Operatoren (z. B. == und !=) sollten immer zusammen √ºberladen werden, 
um konsistentes Verhalten zu gew√§hrleisten.
Beispiel: √úberladen des + Operators

Hier ein Beispiel, wie der + Operator f√ºr eine benutzerdefinierte Klasse Vector √ºberladen werden kann:

Code kopieren
public class Vector
{
    public int X { get; }
    public int Y { get; }

    public Vector(int x, int y)
    {
        X = x;
        Y = y;
    }

    // √úberladen des + Operators
    public static Vector operator +(Vector v1, Vector v2)
    {
        return new Vector(v1.X + v2.X, v1.Y + v2.Y);
    }

    public override string ToString()
    {
        return $"({X}, {Y})";
    }
}

// Verwendung
var v1 = new Vector(1, 2);
var v2 = new Vector(3, 4);
var result = v1 + v2;
Console.WriteLine(result); // Ausgabe: (4, 6)

Vergleichsoperatoren (== und !=)

Wenn Sie Vergleichsoperatoren √ºberladen, sollten Sie auch die Equals-Methode und GetHashCode 
√ºberschreiben, um konsistentes Verhalten sicherzustellen:

Code kopieren
public class Point
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }

    public static bool operator ==(Point p1, Point p2)
    {
        if (ReferenceEquals(p1, p2)) return true;
        if (p1 is null || p2 is null) return false;
        return p1.X == p2.X && p1.Y == p2.Y;
    }

    public static bool operator !=(Point p1, Point p2)
    {
        return !(p1 == p2);
    }

    public override bool Equals(object obj)
    {
        return obj is Point point && this == point;
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(X, Y);
    }
}

Wichtige Hinweise
Lesbarkeit: √úberladen Sie Operatoren nur, wenn es die Lesbarkeit und Verst√§ndlichkeit des Codes 
verbessert.
Konsistenz: Halten Sie das Verhalten der √ºberladenen Operatoren konsistent mit den Erwartungen der 
Benutzer.

Mit diesen Grundlagen k√∂nnen Sie Operatoren in C# effektiv √ºberladen und benutzerdefinierte Typen 
intuitiver gestalten!

--------------

In C#, operator overloading allows you to redefine or extend the behavior of operators for 
user-defined types (like classes or structs). This makes your custom types more intuitive 
and easier to use.

Key Points:
Syntax: Use the operator keyword in combination with the operator you want to overload.
Rules:
Only predefined operators can be overloaded.
You cannot create new operators.
Certain operators (e.g., =) cannot be overloaded.
Commonly Overloaded Operators: Arithmetic (+, -, *, /), comparison (==, !=, <, >), and unary (+, -, !, ~) operators.
Example: Overloading + Operator
Code kopieren
public class Complex
{
    public double Real { get; set; }
    public double Imaginary { get; set; }

    public Complex(double real, double imaginary)
    {
        Real = real;
        Imaginary = imaginary;
    }

    // Overloading the + operator
    public static Complex operator +(Complex c1, Complex c2)
    {
        return new Complex(c1.Real + c2.Real, c1.Imaginary + c2.Imaginary);
    }

    public override string ToString()
    {
        return $"{Real} + {Imaginary}i";
    }
}

// Usage
var c1 = new Complex(1.0, 2.0);
var c2 = new Complex(3.0, 4.0);
var result = c1 + c2;
Console.WriteLine(result); // Output: 4.0 + 6.0i

Example: Overloading == and != Operators
Code kopieren
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }

    // Overloading == operator
    public static bool operator ==(Point p1, Point p2)
    {
        return p1.X == p2.X && p1.Y == p2.Y;
    }

    // Overloading != operator
    public static bool operator !=(Point p1, Point p2)
    {
        return !(p1 == p2);
    }

    public override bool Equals(object obj)
    {
        if (obj is Point p)
        {
            return this == p;
        }
        return false;
    }

    public override int GetHashCode()
    {
        return (X, Y).GetHashCode();
    }
}

// Usage
var p1 = new Point(1, 2);
var p2 = new Point(1, 2);
Console.WriteLine(p1 == p2); // Output: True
Console.WriteLine(p1 != p2); // Output: False

Notes:
Always override Equals and GetHashCode when overloading equality operators (==, !=).
Use operator overloading judiciously to maintain code readability and avoid confusion.

https://w3schools.tech/de/tutorial/csharp/csharp_operator_overloading
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading
https://www.tutorialspoint.com/csharp/csharp_operator_overloading.htm


---------------------------------





using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using HelloWorld;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace HelloWorld
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            Console.WriteLine("Hello, World!");  		
			// A generic list of int.
			GenericList<int> list = new();
			// Add ten int values.
			for (int x = 0; x < 10; x++)
			{
				list.AddHead(x);
			}
			// Write them to the console.
			foreach (int i in list)
			{
				Console.WriteLine(i);
			}
			Console.WriteLine("Done");			
        }
    }

	// Type parameter T in angle brackets.
	public class GenericList<T>
	{
		// The nested class is also generic, and
		// holds a data item of type T.
		private class Node(T t)
		{
			// T as property type.
			public T Data { get; set; } = t;
			public Node? Next { get; set; }
		}

		// First item in the linked list
		private Node? head;

		// T as parameter type.
		public void AddHead(T t)
		{
			Node n = new(t);
			n.Next = head;
			head = n;
		}
		// T in method return type.
		public IEnumerator<T> GetEnumerator()
		{
			Node? current = head;

			while (current is not null)
			{
				yield return current.Data;
				current = current.Next;
			}
		}
	}
	public class ExampleClass { }		
}


https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics



------------------------------------------------

In C#, generic constraints are used to specify the requirements that a type parameter in a 
generic class, method, or interface must meet. These constraints ensure that the type parameter
 has specific capabilities or characteristics. Constraints are defined using the where keyword.

Common Types of Generic Constraints

No Constraint (Default)

If no constraint is specified, the type parameter can be any type (value type, reference type, 
or even System.Object).

where T : struct

Restricts the type parameter to value types (e.g., int, float, DateTime).
Example:
Code kopieren
public class Example<T> where T : struct
{
    public T Value { get; set; }
}


where T : class

Restricts the type parameter to reference types (e.g., string, List<int>).
Example:
Code kopieren
public class Example<T> where T : class
{
    public T Value { get; set; }
}


where T : new()

Requires the type parameter to have a parameterless constructor.
Example:
Code kopieren
public class Example<T> where T : new()
{
    public T CreateInstance()
    {
        return new T();
    }
}


where T : BaseClass

Restricts the type parameter to types that inherit from a specific base class.
Example:
Code kopieren
public class Example<T> where T : BaseClass
{
    public void PrintBaseProperty(T obj)
    {
        Console.WriteLine(obj.BaseProperty);
    }
}


where T : Interface

Restricts the type parameter to types that implement a specific interface.
Example:
Code kopieren
public class Example<T> where T : IDisposable
{
    public void DisposeObject(T obj)
    {
        obj.Dispose();
    }
}


Multiple Constraints

You can combine constraints using commas.
Example:
Code kopieren
public class Example<T> where T : class, new()
{
    public T CreateInstance()
    {
        return new T();
    }
}


where T : U

Restricts the type parameter T to types that are or derive from another type parameter U.
Example:
Code kopieren
public class Example<T, U> where T : U
{
    public void DoSomething(T obj)
    {
        // obj is guaranteed to be of type U or derived from U
    }
}

Why Use Constraints?
To enforce type safety.
To enable specific operations on the type parameter (e.g., calling methods, accessing properties).
To provide better compile-time error checking.

Constraints make generics more powerful and flexible, ensuring that your code works only with 
compatible types.


--------------------

In C#, indexers allow objects to be indexed like arrays. While indexers themselves cannot be 
generic, you can define them in a generic class or generic struct. This allows you to use generic 
types for the indexer parameters or return values.

Here‚Äôs an example of valid generic indexers in C#:

1. Generic Class with Indexer
Code kopieren
public class GenericCollection<T>
{
    private Dictionary<int, T> _items = new Dictionary<int, T>();

    public T this[int index]
    {
        get => _items.ContainsKey(index) ? _items[index] : default;
        set => _items[index] = value;
    }
}

Usage:
Code kopieren
var collection = new GenericCollection<string>();
collection[0] = "Hello";
collection[1] = "World";
Console.WriteLine(collection[0]); // Output: Hello

2. Generic Indexer with Multiple Parameters
Code kopieren
public class Matrix<T>
{
    private T[,] _data;

    public Matrix(int rows, int columns)
    {
        _data = new T[rows, columns];
    }

    public T this[int row, int column]
    {
        get => _data[row, column];
        set => _data[row, column] = value;
    }
}

Usage:
Code kopieren
var matrix = new Matrix<int>(3, 3);
matrix[0, 0] = 42;
Console.WriteLine(matrix[0, 0]); // Output: 42

3. Generic Return Type
Code kopieren
public class KeyValueStore<TKey, TValue>
{
    private Dictionary<TKey, TValue> _store = new Dictionary<TKey, TValue>();

    public TValue this[TKey key]
    {
        get => _store.ContainsKey(key) ? _store[key] : default;
        set => _store[key] = value;
    }
}

Usage:
Code kopieren
var store = new KeyValueStore<string, int>();
store["Age"] = 30;
Console.WriteLine(store["Age"]); // Output: 30

Key Notes:
Indexers cannot themselves be generic, but they can exist in generic types.
Indexers can take multiple parameters, and their types can be generic.
Use Dictionary, List, or arrays internally to manage the indexed data efficiently.

This approach provides flexibility and allows you to create reusable, type-safe collections!



..................

In C#, you can define and override generic indexers in a class. Indexers allow objects to be 
indexed like arrays, and when combined with generics, they provide flexibility for handling
 various data types. Below is an example demonstrating how to define and override a generic indexer:

Example Code
Code kopieren
using System;

public class BaseClass<T>
{
    private T[] items = new T[10];

    // Generic indexer in the base class
    public virtual T this[int index]
    {
        get => items[index];
        set => items[index] = value;
    }
}

public class DerivedClass<T> : BaseClass<T>
{
    // Overriding the generic indexer
    public override T this[int index]
    {
        get
        {
            Console.WriteLine($"Getting value at index {index} in DerivedClass");
            return base[index];
        }
        set
        {
            Console.WriteLine($"Setting value at index {index} in DerivedClass");
            base[index] = value;
        }
    }
}

public class Program
{
    public static void Main()
    {
        var derived = new DerivedClass<string>();
        derived[0] = "Hello";
        Console.WriteLine(derived[0]);
    }
}

Explanation

Base Class:

Defines a generic indexer this[int index] that works with type T.
Uses an internal array to store values.

Derived Class:

Overrides the base class's generic indexer.
Adds custom behavior (e.g., logging) while still using the base class's implementation.

Usage:

The derived class's indexer is used to set and get values, demonstrating the overridden behavior.

This approach allows you to customize the behavior of indexers in derived classes while maintaining 
the flexibility of generics.


----------------------------------------------------------



In C#, you can use indexers to define generic classes that allow indexed access to their elements.
 Indexers are similar to properties but use parameters to define the index. Here's an example 
 of how to implement a generic class with get and set accessors for indexed values:

Example 1: Generic Indexer
Code kopieren
using System;

public class GenericList<T>
{
    private T[] items = new T[10];

    public T this[int index]
    {
        get
        {
            if (index < 0 || index >= items.Length)
                throw new IndexOutOfRangeException("Index out of range.");
            return items[index];
        }
        set
        {
            if (index < 0 || index >= items.Length)
                throw new IndexOutOfRangeException("Index out of range.");
            items[index] = value;
        }
    }
}

class Program
{
    static void Main()
    {
        var list = new GenericList<string>();
        list[0] = "Hello";
        list[1] = "World";

        Console.WriteLine(list[0]); // Output: Hello
        Console.WriteLine(list[1]); // Output: World
    }
}

Explanation:
Generic Class: GenericList<T> is a generic class that can store any type of data.
Indexer: The this[int index] defines the indexer, allowing you to use array-like syntax to 
access elements.
Bounds Checking: The get and set accessors include checks to ensure the index is within valid bounds.
Example 2: Read-Only Indexer

If you want to make the indexer read-only, you can omit the set accessor:

Code kopieren
public T this[int index]
{
    get
    {
        if (index < 0 || index >= items.Length)
            throw new IndexOutOfRangeException("Index out of range.");
        return items[index];
    }
}


This approach is useful when you want to expose data without allowing modifications.

Example 3: Using a Dictionary for Flexible Indexing

If you need non-integer keys, you can use a Dictionary:

Code kopieren
using System.Collections.Generic;

public class GenericDictionary<K, V>
{
    private Dictionary<K, V> dictionary = new Dictionary<K, V>();

    public V this[K key]
    {
        get => dictionary.ContainsKey(key) ? dictionary[key] : default;
        set => dictionary[key] = value;
    }
}


This allows you to use custom keys for indexing, providing more flexibility.


------------------


